#!/usr/bin/env python3
"""
Base plugin class for NutriHelp Security Scanner V2.0
"""

from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional, Union
import logging
import os
from datetime import datetime


class SecurityFinding:
    """Standardized security discovery objects"""

    def __init__(self, title: str, severity: str, file_path: str,
                 description: str, line_number: Optional[int] = None,
                 plugin: Optional[str] = None, recommendation: Optional[Union[str, Dict[str, Any]]] = None,
                 rule_id: Optional[str] = None, rule_name: Optional[str] = None,
                 rule_mode: Optional[str] = None, confidence: Optional[str] = None,
                 route: Optional[str] = None, http_method: Optional[str] = None):

        self.title = title
        self.severity = severity
        self.file_path = file_path
        self.description = description
        self.line_number = line_number
        self.plugin = plugin
        self.recommendation = recommendation
        self.rule_id = rule_id
        self.rule_name = rule_name
        self.rule_mode = rule_mode
        self.confidence = confidence
        # optional route information for API-related findings
        self.route = route
        self.http_method = http_method

    def to_dict(self) -> Dict[str, Any]:
        return {
            'title': self.title,
            'severity': self.severity,
            'file_path': self.file_path,
            'line_number': self.line_number,
            'description': self.description,
            'plugin_name': self.plugin,
            'recommendation': self.recommendation,
            'rule_id': getattr(self, 'rule_id', None),
            'rule_name': getattr(self, 'rule_name', None),
            'rule_mode': getattr(self, 'rule_mode', None),
            'confidence': getattr(self, 'confidence', None),
            'route': getattr(self, 'route', None),
            'http_method': getattr(self, 'http_method', None)
        }



class BaseSecurityPlugin(ABC):
    """Base class for all security plugins"""

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.config = config or {}
        self.name = self.__class__.__name__
        self.findings: List[SecurityFinding] = []
        self.logger = logging.getLogger(f"SecurityPlugin.{self.name}")
        self._setup_logging()
    
    def _setup_logging(self):
        """Set up logging configuration"""
        if not self.logger.handlers:
            handler = logging.StreamHandler()
            formatter = logging.Formatter(
                '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
            )
            handler.setFormatter(formatter)
            self.logger.addHandler(handler)
            self.logger.setLevel(logging.INFO)
    
    @abstractmethod
    def get_plugin_info(self) -> Dict[str, str]:
        """Return plugin metadata information"""
        pass
    
    @abstractmethod
    def scan(self, target_path: str) -> List[SecurityFinding]:
        """Perform security scan and return discovered issues"""
        pass
    
    @abstractmethod
    def get_severity_level(self) -> str:
        """Return default severity level for issues detected by the plugin"""
        pass
    
    def add_finding(self, title: str, description: str, file_path: str,
                   line_number: Optional[int] = None, severity: Optional[str] = None,
                   recommendation: Optional[str] = None, rule_id: Optional[str] = None,
                   rule_name: Optional[str] = None, rule_mode: Optional[str] = None,
                   confidence: Optional[str] = None) -> SecurityFinding:
        """Add security finding"""
        if severity is None:
            severity = self.get_severity_level()
        
        finding = SecurityFinding(
            title=title,
            severity=severity,
            file_path=file_path,
            description=description,
            line_number=line_number,
            recommendation=recommendation,
            rule_id=rule_id,
            rule_name=rule_name,
            rule_mode=rule_mode,
            confidence=confidence
        )
        finding.plugin = self.name
        self.findings.append(finding)
        
        self.logger.info(f"Added {severity} finding: {title}")
        return finding
    
    def clear_findings(self):
        """Clear all findings"""
        self.findings.clear()
    
    def is_file_scannable(self, file_path: str) -> bool:
        """Check if a file is scannable"""
        # Respect plugin-level exclude_paths first (substring match)
        exclude_paths = self.config.get('exclude_paths', [])
        try:
            if any(p and p in file_path for p in exclude_paths):
                return False
        except Exception:
            # fallback to normal behavior on unexpected errors
            pass

        # Get supported file extensions
        supported_extensions = self.config.get('file_extensions', ['.js', '.py', '.ts'])
        file_ext = os.path.splitext(file_path)[1].lower()
        return file_ext in supported_extensions
    
    def should_skip_directory(self, dir_path: str) -> bool:
        """Check if a directory should be skipped"""
        # engine/plugin-level directory skip list
        skip_dirs = self.config.get('skip_directories', [
            'node_modules', '.git', '__pycache__', 'venv', '.venv'
        ])
        dir_name = os.path.basename(dir_path)
        if dir_name in skip_dirs:
            return True

        # Also honor plugin-level exclude_paths which may be substrings of paths
        exclude_paths = self.config.get('exclude_paths', [])
        try:
            if any(p and p in dir_path for p in exclude_paths):
                return True
        except Exception:
            pass

        return False
    
    def read_file_safe(self, file_path: str) -> Optional[str]:
        """Safely read file content"""
        # Respect exclude_paths before attempting to read
        exclude_paths = self.config.get('exclude_paths', [])
        try:
            if any(p and p in file_path for p in exclude_paths):
                self.logger.debug(f"Skipping read for excluded path: {file_path}")
                return None
        except Exception:
            # proceed to read if exclude_paths check fails
            pass

        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except (UnicodeDecodeError, PermissionError) as e:
            self.logger.warning(f"Cannot read file {file_path}: {e}")
            return None
    
    def get_relative_path(self, file_path: str, base_path: str) -> str:
        """Get relative path"""
        try:
            return os.path.relpath(file_path, base_path)
        except ValueError:
            return file_path


class PluginManager:
    """Plugin manager"""

    def __init__(self):
        self.plugins: List[BaseSecurityPlugin] = []
        self.logger = logging.getLogger("PluginManager")
    
    def register_plugin(self, plugin: BaseSecurityPlugin):
        """Register plugin"""
        self.plugins.append(plugin)
        info = plugin.get_plugin_info()
        self.logger.info(f"Registered plugin: {info['name']} v{info['version']}")
    
    def get_plugins(self) -> List[BaseSecurityPlugin]:
        """Get all registered plugins"""
        return self.plugins
    
    def run_all_scans(self, target_path: str) -> Dict[str, List[SecurityFinding]]:
        """Run all plugin scans"""
        results = {}
        
        for plugin in self.plugins:
            plugin.clear_findings()  # Clear previous results
            try:
                findings = plugin.scan(target_path)
                results[plugin.name] = findings
                self.logger.info(f"Plugin {plugin.name} found {len(findings)} issues")
            except Exception as e:
                self.logger.error(f"Plugin {plugin.name} failed: {e}")
                results[plugin.name] = []
        
        return results