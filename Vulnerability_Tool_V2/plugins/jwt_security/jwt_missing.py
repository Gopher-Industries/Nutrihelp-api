#!/usr/bin/env python3
"""
JWT Missing Protection Plugin
Detecting API endpoints missing JWT protection
"""

import os
import re
import logging
from typing import List, Dict, Any, Optional
from plugins.base_plugin import BaseSecurityPlugin, SecurityFinding

class JWTMissingProtectionPlugin(BaseSecurityPlugin):
    """JWT Missing Protection Detection Plugin"""

    name = "JWT Missing Protection Detector"
    version = "2.0.0"
    description = "Detect API endpoints missing JWT authentication protection"

    def __init__(self, config: Dict[str, Any] = None):
        super().__init__(config or {})
        self.logger = logging.getLogger(__name__)

        # Public endpoints (no JWT protection needed)
        self.public_endpoints = {
            '/health', '/api-docs', '/swagger', '/login', '/register',
            '/auth/login', '/auth/register', '/auth/refresh', '/signup',
            '/contactus', '/articles'
        }
        
        # File extensions to scan
        self.target_extensions = ('.js', '.ts', '.py')

    def get_plugin_info(self) -> Dict[str, str]:
        return {
            "id": "jwt_missing_protection",
            "name": self.name,
            "version": self.version,
            "description": self.description,
        }

    def get_severity_level(self) -> str:
        return "medium"

    def scan(self, target_path: str = None) -> List[SecurityFinding]:
        """Scan the target path for missing JWT protection endpoints"""
        findings = []
        
        if not target_path or not os.path.exists(target_path):
            return findings
        
        try:
            for root, dirs, files in os.walk(target_path):
                # Skip specific directories
                dirs[:] = [d for d in dirs if d not in {'.git', 'node_modules', '__pycache__', '.venv'}]
                
                for file in files:
                    if file.endswith(self.target_extensions):
                        file_path = os.path.join(root, file)
                        file_findings = self._scan_file(file_path, target_path)
                        findings.extend(file_findings)
        
        except Exception as e:
            self.logger.error(f"Error occurred during scanning: {e}")

        return findings

    def _scan_file(self, file_path: str, base_path: str) -> List[SecurityFinding]:
        """Scan a single file"""
        findings = []
        
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
                lines = content.split('\n')
            
            relative_path = os.path.relpath(file_path, base_path)

            # Check route definitions
            route_patterns = [
                r'app\.(get|post|put|delete|patch)\s*\(\s*[\'"`]([^\'"`]+)[\'"`]',
                r'router\.(get|post|put|delete|patch)\s*\(\s*[\'"`]([^\'"`]+)[\'"`]',
            ]
            
            for i, line in enumerate(lines, 1):
                for pattern in route_patterns:
                    matches = re.finditer(pattern, line, re.IGNORECASE)
                    
                    for match in matches:
                        if len(match.groups()) >= 2:
                            method = match.group(1).upper()
                            endpoint = match.group(2)
                        else:
                            continue

                        # Skip public endpoints
                        if self._is_public_endpoint(endpoint):
                            continue

                        # Check for JWT protection
                        if not self._has_jwt_protection(line, lines, i):
                            # Create finding via helper to ensure consistent fields
                            finding = self.add_finding(
                                title=f"Missing JWT Protection: {method} {endpoint}",
                                description=f"API endpoint {method} {endpoint} lacks JWT authentication middleware",
                                file_path=relative_path,
                                line_number=i,
                                severity="MEDIUM",
                                recommendation=self._get_recommendation(endpoint, method)
                            )
                            # add route metadata so engine can apply public/protected filtering
                            try:
                                # standardized route: endpoint path only (e.g. '/users')
                                finding.route = endpoint
                                finding.http_method = method
                            except Exception:
                                pass
                            findings.append(finding)
        
        except Exception as e:
            self.logger.error(f"Error occurred while scanning file {file_path}: {e}")

        return findings

    def _is_public_endpoint(self, endpoint: str) -> bool:
        """Check if the endpoint is public"""
        endpoint = endpoint.lower()
        return any(pub in endpoint for pub in self.public_endpoints)

    def _has_jwt_protection(self, line: str, all_lines: List[str], line_number: int) -> bool:
        """Check for JWT protection middleware"""
        # Check current line
        jwt_patterns = [
            'authenticateToken', 'authMiddleware', 'verifyToken',
            'requireAuth', 'jwt', 'authenticate'
        ]
        
        line_lower = line.lower()
        if any(pattern.lower() in line_lower for pattern in jwt_patterns):
            return True

        # Check surrounding lines
        start = max(0, line_number - 3)
        end = min(len(all_lines), line_number + 3)
        
        for i in range(start, end):
            if i < len(all_lines):
                check_line = all_lines[i].lower()
                if any(pattern.lower() in check_line for pattern in jwt_patterns):
                    return True
        
        return False

    def _get_recommendation(self, endpoint: str, method: str) -> str:
        """Get fix recommendation"""
        # Return a structured recommendation
        return {
            'summary': f'Protect the {method} {endpoint} endpoint with authentication middleware.',
            'steps': [
                f"Import authentication middleware: const authenticateToken = require('../middleware/authenticateToken');",
                f"Add middleware to route: router.{method.lower()}('{endpoint}', authenticateToken, (req, res) => {{ /* handler */ }});",
                "Ensure JWT configuration is secure: use strong secrets, set appropriate expiration, and handle errors properly."
            ],
            'code': f"router.{method.lower()}('{endpoint}', authenticateToken, (req, res) => {{\n  // Your route handler\n}});"
        }

    def run(self, target_path: str = None) -> List[SecurityFinding]:
        """Backward compatibility method"""
        return self.scan(target_path)

# Export plugin class
Plugin = JWTMissingProtectionPlugin

def test_plugin():
    """Test plugin functionality"""
    try:
        plugin = JWTMissingProtectionPlugin()
        info = plugin.get_plugin_info()
        print("Plugin Info:", info)
        print("✅ JWT Missing Protection Plugin initialized successfully")
        return True
    except Exception as e:
        print(f"❌ Plugin test failed: {e}")
        return False

if __name__ == '__main__':
    test_plugin()