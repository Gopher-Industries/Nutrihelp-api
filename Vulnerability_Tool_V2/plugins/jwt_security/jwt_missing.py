#!/usr/bin/env python3
"""
JWT Missing Protection Plugin - Updated for NutriHelp's actual architecture
Implementing a custom detection plugin based on existing JWT architecture
"""

import os
import re
import glob  
import fnmatch
from typing import List, Dict, Any
from ..base_plugin import BaseSecurityPlugin, SecurityFinding


class JWTMissingProtectionPlugin(BaseSecurityPlugin):
    """Detects API endpoints missing JWT protection - Optimized for NutriHelp's actual architecture"""
    
    def __init__(self, *args, **kwargs):  
        super().__init__(*args, **kwargs)  
        self._findings_cache = set()  

    def get_plugin_info(self) -> Dict[str, str]:
        return {
            'name': 'JWT Missing Protection Detector',
            'version': '2.0.1',
            'description': 'Detects API endpoints missing JWT authentication middleware (NutriHelp optimized)',
            'author': 'NutriHelp Security Team'
        }
    
    def get_severity_level(self) -> str:
        return "HIGH"
    
    def scan(self, target_path: str) -> List[SecurityFinding]:
        """Scan for missing JWT protection."""
        findings = []
        
        for route_file in self._find_route_files(target_path):
            self._analyze_route_file(route_file, target_path)
        
        return self.findings  # Return all collected findings

    def _analyze_route_file(self, file_path: str, base_path: str):
        """Analyze a single route file."""
        try:
            content = self.read_file_safe(file_path)
            if not content:
                return
            
            lines = content.split('\n')
            relative_path = self.get_relative_path(file_path, base_path)

            route_patterns = [
                r'router\.(get|post|put|delete|patch)\s*\(\s*[\'"`]([^\'"`]+)[\'"`]'
            ]
            
            for i, line in enumerate(lines, 1):
                for pattern in route_patterns:
                    matches = re.finditer(pattern, line, re.IGNORECASE)
                    
                    for match in matches:
                        method = match.group(1).upper()
                        path = match.group(2)
                        
                        if not self._has_jwt_protection(line, lines, i):
                            severity = self._determine_severity(path, method, os.path.basename(file_path))
                            recommendation = self._get_recommendation(method, path)
                            
                            self.add_finding(
                                title=f"Missing JWT Protection: {method} {path}",
                                description=f"API endpoint {method} {path} in {os.path.basename(file_path)} lacks JWT authentication middleware. Based on your current architecture, this should use authenticateToken middleware.",
                                file_path=relative_path,
                                line_number=i,
                                severity=severity,
                                recommendation=recommendation
                            )
                    
        except Exception as e:
            self.logger.error(f"Error analyzing route file {file_path}: {e}")

    def _check_line_for_unprotected_routes(self, line: str, all_lines: List[str], 
                                          line_number: int, file_path: str, 
                                          route_patterns: List[str], filename: str):
        """Check for unprotected routes in a single line of code - based on existing middleware names"""
        
        for pattern in route_patterns:
            matches = re.finditer(pattern, line, re.IGNORECASE)
            
            for match in matches:
                if len(match.groups()) >= 2:
                    method = match.group(1).upper() if match.group(1) else 'USE'
                    endpoint = match.group(2)
                    
                    # Handling different endpoint formats
                    if not endpoint.startswith('/'):
                        endpoint = '/' + endpoint
                else:
                    continue

                # Skip explicitly public endpoints
                if self._is_public_endpoint(endpoint, filename):
                    continue

                # Check for JWT protection - using existing middleware names
                if not self._has_jwt_protection(line, all_lines, line_number):
                    severity = self._determine_severity(endpoint, method, filename)
                    recommendation = self._get_recommendation(endpoint, method)
                    
                    self.add_finding(
                        title=f"Missing JWT Protection: {method} {endpoint}",
                        description=f"API endpoint {method} {endpoint} in {filename} lacks JWT authentication middleware. "
                                  f"Based on your current architecture, this should use authenticateToken middleware.",
                        file_path=file_path,
                        line_number=line_number,
                        severity=severity,
                        recommendation=recommendation
                    )
    
    def _is_public_endpoint(self, endpoint: str, filename: str) -> bool:
        """Check if an endpoint should be public - based on existing route structure"""

        # Based on filename, determine public endpoints
        if filename in ['login.js', 'signup.js']:
            return True

        # Explicit public endpoints (based on existing auth.js)
        public_endpoints = [
            '/register', '/login', '/health', '/api-docs', '/docs',
            '/public', '/static', '/uploads', '/log-login', '/log-login-attempt'
        ]
        
        endpoint_lower = endpoint.lower()

        # Exact match
        if endpoint_lower in [ep.lower() for ep in public_endpoints]:
            return True

        # Prefix match
        public_prefixes = ['/public/', '/static/', '/docs/', '/uploads/', '/api-docs/']
        if any(endpoint_lower.startswith(prefix) for prefix in public_prefixes):
            return True

        # Health check endpoints
        if any(pattern in endpoint_lower for pattern in ['/health', '/ping', '/status']):
            return True
        
        return False
    
    def _has_jwt_protection(self, current_line: str, all_lines: List[str], line_number: int) -> bool:
        """Check if route has JWT protection."""
        # Predefined exemption routes
        exempt_routes = [
            '/health', 
            '/status',
            '/login',
            '/register',
            '/public',
            '/docs'
        ]

        # Check if it's an exempt route
        if any(route in current_line for route in exempt_routes):
            return True

        # Check for JWT protection in context
        context_start = max(0, line_number - 5)
        context_end = min(len(all_lines), line_number + 5)
        context = '\n'.join(all_lines[context_start:context_end])

        # JWT protection patterns
        protection_patterns = [
            'authenticateToken',
            'requireAuth',
            'isAuthenticated',
            'checkJwt',
            'verifyToken'
        ]

        # Check if the route has JWT protection
        return any(pattern in context for pattern in protection_patterns)
    
    def _determine_severity(self, endpoint: str, method: str, filename: str) -> str:
        """Determine severity based on endpoint and method."""
        endpoint_lower = endpoint.lower()

        # CRITICAL - Involves user data and sensitive operations
        if any(sensitive in endpoint_lower for sensitive in [
            'user', 'profile', 'password', 'admin', 'token', 
            'auth', 'key', 'secret', 'credential'
        ]):
            return "CRITICAL"

        # HIGH - Data modification operations
        if method in ['POST', 'PUT', 'DELETE', 'PATCH'] and not any(
            safe in endpoint_lower for safe in [
                'login', 'register', 'public', 'health'
            ]
        ):
            return "HIGH"

        # MEDIUM - Data reading operations
        if method == 'GET' and any(sensitive in endpoint_lower for sensitive in [
            'user', 'data', 'profile', 'report', 'log'
        ]):
            return "MEDIUM"

        # LOW - Other operations
        if method == 'GET' and any(public in endpoint_lower for public in [
            'public', 'health', 'status', 'version'
        ]):
            return "LOW"

        # Default to MEDIUM
        return "MEDIUM"

    def _get_recommendation(self, method: str, endpoint: str) -> str:
        """Generate specific recommendation."""
        return f"""To fix this JWT protection issue, add the authenticateToken middleware:

1. Import the middleware (if not already imported):
   const {{ authenticateToken }} = require('../middleware/authenticateToken');

2. Add middleware to the route:
   router.{method.lower()}('{endpoint}', authenticateToken, (req, res) => {{ ... }});
   
3. For optional authentication, you can use:
   const {{ optionalAuth }} = require('../middleware/authenticateToken');

4. Your current JWT setup uses:
   - Access tokens (15 minutes expiry)
   - Refresh tokens (7 days expiry) 
   - Proper error handling with specific error codes"""

    def _find_route_files(self, base_path: str) -> List[str]:
        """Find all route files in the project."""
        route_files = set()  # Use collection deduplication

        # Define directories and file patterns to scan
        scan_patterns = [
            'routes/*.js',           # Main route directory
            'src/routes/*.js',       # Routes under src
            'api/routes/*.js',       # Routes under api
            '**/routes/*.js',        # Routes directory at any depth
        ]

        # Define patterns to exclude
        exclude_patterns = [
            '**/node_modules/**',    # Exclude node_modules
            '**/test/**',            # Exclude test files
            '**/tests/**',
            '**/mock/**',           # Exclude mock files
            '**/*.test.js',
            '**/*.spec.js'
        ]
        
        try:
            for pattern in scan_patterns:
                full_pattern = os.path.join(base_path, pattern)
                matches = glob.glob(full_pattern, recursive=True)

                # Filter out excluded files
                filtered_matches = [
                    f for f in matches
                    if not any(fnmatch.fnmatch(f, os.path.join(base_path, ep)) 
                              for ep in exclude_patterns)
                ]
                
                route_files.update(filtered_matches)
        
            self.logger.info(f"Found {len(route_files)} route files to scan")
            
        except Exception as e:
            self.logger.error(f"Error finding route files: {e}")
        
        return list(route_files)

    def _cache_key(self, finding: dict) -> str:
        """Generate a unique key for finding."""
        return f"{finding['file_path']}:{finding['line_number']}:{finding['title']}"

    def add_finding(self, **kwargs):
        """Add finding with deduplication."""
        cache_key = self._cache_key(kwargs)
        
        if cache_key not in self._findings_cache:
            self._findings_cache.add(cache_key)
            self.findings.append(SecurityFinding(**kwargs))

    def generate_recommendation(self, route_info: dict) -> str:
        """Generate specific recommendation based on route info"""
        method = route_info['method']
        path = route_info['path']
        file_name = os.path.basename(route_info.get('file_path', ''))

        # Generate specific recommendations for different types of routes
        if 'user' in path.lower() or 'profile' in path.lower():
            return f"""This endpoint ({method} {path}) handles user data and requires strong authentication:

1. Import the JWT middleware:
   const {{ authenticateToken }} = require('../middleware/authenticateToken');

2. Add strict authentication:
   router.{method.lower()}('{path}', authenticateToken, (req, res) => {{
     // Verify user ID matches authenticated user
     if (req.user.id !== req.params.userId) {{
       return res.status(403).json({{ error: 'Unauthorized access' }});
     }}
     // ... rest of your code
   }});"""

        elif method in ['POST', 'PUT', 'DELETE']:
            return f"""This endpoint ({method} {path}) modifies data and requires authentication:

1. Import the JWT middleware:
   const {{ authenticateToken }} = require('../middleware/authenticateToken');

2. Add authentication to protect data modification:
   router.{method.lower()}('{path}', authenticateToken, yourController);

3. Verify request in controller:
   function yourController(req, res) {{
     // Ensure user has required permissions
     if (!req.user.permissions.includes('{path.split("/")[1]}')) {{
       return res.status(403).json({{ error: 'Insufficient permissions' }});
     }}
     // ... rest of your code
   }}"""

        else:
            return f"""Add JWT authentication to protect this endpoint:

1. Import the middleware:
   const {{ authenticateToken }} = require('../middleware/authenticateToken');

2. Add middleware to route:
   router.{method.lower()}('{path}', authenticateToken, (req, res) => {{ ... }});

3. Consider using optional authentication if this is a public endpoint:
   const {{ optionalAuth }} = require('../middleware/authenticateToken');
   router.{method.lower()}('{path}', optionalAuth, (req, res) => {{ ... }});"""


# Test function
def test_plugin():
    """Test plugin basic functionality"""
    plugin = JWTMissingProtectionPlugin()
    
    print("Plugin Info:", plugin.get_plugin_info())
    print("Severity Level:", plugin.get_severity_level())
    print("âœ… Updated JWT Missing Protection Plugin initialized successfully")


if __name__ == '__main__':
    test_plugin()