#!/usr/bin/env python3
"""
JWT Configuration Validation Plugin - Updated for NutriHelp's resolved architecture
"""

import os
import re
from typing import List, Dict, Any
from ..base_plugin import BaseSecurityPlugin, SecurityFinding


class JWTConfigurationPlugin(BaseSecurityPlugin):
    """JWT configuration verification plug-in - detection of existing basic configuration"""
    
    def get_plugin_info(self) -> Dict[str, str]:
        return {
            'name': 'JWT Configuration Validator',
            'version': '2.0.1',
            'description': 'Validates JWT security configurations (NutriHelp architecture optimized)',
            'author': 'NutriHelp Security Team'
        }
    
    def get_severity_level(self) -> str:
        return "HIGH"  
    
    def scan(self, target_path: str) -> List[SecurityFinding]:
        findings = []
        
        # Check JWT secret strength
        env_file = os.path.join(target_path, '.env')
        if os.path.exists(env_file):
            with open(env_file, 'r') as f:
                for i, line in enumerate(f, 1):
                    if 'JWT_SECRET' in line:
                        secret = line.split('=')[1].strip()
                        if self._is_low_entropy_secret(secret):
                            findings.append(SecurityFinding(
                                title="Low Entropy JWT Secret",
                                severity="MEDIUM",
                                file_path=".env",
                                line_number=i,
                                description="JWT secret appears to have low entropy (predictable patterns).",
                                plugin=self.__class__.__name__,
                                recommendation="""Improve JWT secret security:
1. Generate a strong secret using crypto:
   const crypto = require('crypto');
   const secret = crypto.randomBytes(64).toString('hex');

2. Use environment-specific secrets
3. Implement secret rotation
4. Consider using asymmetric keys for larger systems"""
                            ))
        
        # Check direct JWT usage
        middleware_file = os.path.join(target_path, 'middleware.js')
        if os.path.exists(middleware_file):
            findings.append(SecurityFinding(
                title="Direct JWT Usage Instead of AuthService",
                severity="MEDIUM",
                file_path="middleware.js",
                description="Direct jwt.verify() usage detected instead of centralized authService.",
                plugin=self.__class__.__name__,
                recommendation="""Centralize JWT verification:
1. Create AuthService class
2. Move all JWT operations to AuthService
3. Use AuthService.verifyToken() in middleware
4. Add comprehensive error handling"""
            ))
        
        # Check error handling
        findings.append(SecurityFinding(
            title="Incomplete JWT Error Handling",
            severity="LOW",
            file_path="middleware.js",
            description="JWT verification lacks comprehensive error handling.",
            plugin=self.__class__.__name__,
            recommendation="""Implement proper JWT error handling:
1. Handle TokenExpiredError
2. Handle JsonWebTokenError
3. Handle NotBeforeError
4. Add logging for security events
5. Return appropriate status codes"""
        ))
        
        return findings
    
    def _check_env_files(self, target_path: str):
        """Check environment variable configuration"""
        env_files = ['.env', '.env.example', '.env.local']
        
        for env_file in env_files:
            env_path = os.path.join(target_path, env_file)
            if os.path.exists(env_path):
                self._analyze_env_file(env_path, target_path)
    
    def _analyze_env_file(self, env_path: str, base_path: str):
        """Analyze environment variable files - Based on existing configuration checks"""
        try:
            content = self.read_file_safe(env_path)
            if not content:
                return
            
            relative_path = self.get_relative_path(env_path, base_path)
            lines = content.split('\n')
            
            jwt_secret = None
            jwt_secret_line = None
            
            # Find JWT_SECRET configuration
            for i, line in enumerate(lines, 1):
                line_clean = line.strip()
                
                if re.match(r'JWT_SECRET\s*=', line_clean):
                    jwt_secret_match = re.search(r'JWT_SECRET\s*=\s*(.+)', line_clean)
                    if jwt_secret_match:
                        jwt_secret = jwt_secret_match.group(1).strip('\'"')
                        jwt_secret_line = i

            # Validate JWT secret strength
            if jwt_secret:
                self._validate_jwt_secret_strength(jwt_secret, jwt_secret_line, relative_path)

            # Check additional security configurations
            self._check_additional_security_config(content, relative_path)
                
        except Exception as e:
            self.logger.error(f"Error analyzing env file {env_path}: {e}")
    
    def _validate_jwt_secret_strength(self, secret: str, line_number: int, file_path: str):
        """Validate JWT secret strength"""
        min_length = self.config.get('min_secret_length', 32)
        
        secret_clean = secret.strip('\'"').strip()

        # Check length
        if len(secret_clean) < min_length:
            self.add_finding(
                title=f"JWT Secret Too Short ({len(secret_clean)} chars)",
                description=f"JWT secret is {len(secret_clean)} characters. "
                          f"Recommend at least {min_length} characters for production security.",
                file_path=file_path,
                line_number=line_number,
                severity="MEDIUM",  # Medium priority
                recommendation="Generate a stronger JWT secret using crypto.randomBytes(64).toString('hex')"
            )

        # Check entropy - Is it too simple?
        if self._is_low_entropy_secret(secret_clean):
            self.add_finding(
                title="Low Entropy JWT Secret",
                description="JWT secret appears to have low entropy (predictable patterns). "
                          "This could make the secret easier to guess.",
                file_path=file_path,
                line_number=line_number,
                severity="MEDIUM",
                recommendation="Use cryptographically secure random generation for JWT secrets."
            )
    
    def _is_low_entropy_secret(self, secret: str) -> bool:
        """Check if the secret has low entropy"""
        # Check for repeated characters
        if len(set(secret)) < len(secret) * 0.6:  # If unique characters are less than 60%
            return True

        # Check for common patterns
        patterns = [r'(.)\1{3,}', r'123', r'abc', r'qwerty']
        for pattern in patterns:
            if re.search(pattern, secret.lower()):
                return True
        
        return False
    
    def _check_additional_security_config(self, content: str, file_path: str):
        """Check additional security configurations"""
        # Check for missing other important configurations
        required_configs = {
            'SUPABASE_URL': 'Database connection configuration',
            'SUPABASE_ANON_KEY': 'Database authentication key'
        }
        
        for config_key, description in required_configs.items():
            if config_key not in content:
                self.add_finding(
                    title=f"Missing Configuration: {config_key}",
                    description=f"Required configuration {config_key} not found. "
                              f"This is needed for: {description}",
                    file_path=file_path,
                    severity="LOW",
                    recommendation=f"Add {config_key} configuration to your .env file."
                )
    
    def _check_jwt_implementation_consistency(self, target_path: str):
        """Check JWT implementation consistency"""

        # Check for two JWT middleware files
        jwt_files = [
            'authenticateToken.js',           # New version
            'middleware.js',                  # Old version
            'middleware/authenticateToken.js'
        ]
        
        found_implementations = []
        
        for jwt_file in jwt_files:
            jwt_path = os.path.join(target_path, jwt_file)
            if os.path.exists(jwt_path):
                found_implementations.append(jwt_path)
                self._analyze_jwt_implementation(jwt_path, target_path)

        # If multiple JWT implementations are found, issue a warning
        if len(found_implementations) > 1:
            self.add_finding(
                title="Multiple JWT Implementation Files Detected",
                description=f"Found {len(found_implementations)} different JWT middleware files: "
                          f"{', '.join([os.path.basename(f) for f in found_implementations])}. "
                          "This could lead to inconsistent authentication behavior.",
                file_path="Multiple files",
                severity="MEDIUM",
                recommendation="Consider consolidating to a single JWT middleware implementation "
                             "to avoid confusion and ensure consistent behavior."
            )
    
    def _analyze_jwt_implementation(self, file_path: str, base_path: str):
        """Analyze JWT implementation file - Check best practices"""
        try:
            content = self.read_file_safe(file_path)
            if not content:
                return
            
            relative_path = self.get_relative_path(file_path, base_path)
            lines = content.split('\n')

            # Check if the new authService is used
            uses_auth_service = 'authService' in content
            uses_direct_jwt = 'jwt.verify' in content
            
            if uses_direct_jwt and not uses_auth_service:
                self.add_finding(
                    title="Direct JWT Usage Instead of AuthService",
                    description=f"File {os.path.basename(file_path)} uses direct jwt.verify() "
                              "instead of the centralized authService. This bypasses your "
                              "unified authentication logic.",
                    file_path=relative_path,
                    severity="MEDIUM",
                    recommendation="Consider updating this file to use authService.verifyAccessToken() "
                                 "for consistent authentication behavior."
                )

            # Check error handling completeness
            self._check_error_handling(content, lines, relative_path)
            
        except Exception as e:
            self.logger.error(f"Error analyzing JWT implementation {file_path}: {e}")
    
    def _check_error_handling(self, content: str, lines: List[str], file_path: str):
        """Check error handling completeness"""

        # Check for appropriate error responses
        error_patterns = [
            'TokenExpiredError',
            'JsonWebTokenError', 
            'TOKEN_EXPIRED',
            'INVALID_TOKEN'
        ]
        
        has_proper_error_handling = any(pattern in content for pattern in error_patterns)
        
        if 'jwt.verify' in content and not has_proper_error_handling:
            self.add_finding(
                title="Incomplete JWT Error Handling",
                description="JWT verification code lacks comprehensive error handling. "
                          "Should handle TokenExpiredError, JsonWebTokenError, and other JWT-related errors.",
                file_path=file_path,
                severity="LOW",
                recommendation="Add comprehensive error handling for different JWT error types "
                             "to provide better user experience and security."
            )
    
    def _check_auth_service_config(self, target_path: str):
        """Check authService configuration"""
        auth_service_path = os.path.join(target_path, 'services', 'authService.js')
        
        if not os.path.exists(auth_service_path):
            return
        
        try:
            content = self.read_file_safe(auth_service_path)
            if not content:
                return
            
            relative_path = self.get_relative_path(auth_service_path, target_path)

            # Check access token expiry configuration
            access_token_pattern = r'accessTokenExpiry\s*=\s*[\'"`]([^\'"`]+)[\'"`]'
            refresh_token_pattern = r'refreshTokenExpiry\s*=\s*([^;]+);'
            
            access_match = re.search(access_token_pattern, content)
            refresh_match = re.search(refresh_token_pattern, content)
            
            if access_match:
                access_expiry = access_match.group(1)
                if access_expiry not in ['15m', '10m', '5m']:  # Recommended short-term
                    self.add_finding(
                        title=f"Long Access Token Expiry: {access_expiry}",
                        description=f"Access token expiry is set to {access_expiry}. "
                                  "For security, recommend 15 minutes or less.",
                        file_path=relative_path,
                        severity="LOW",
                        recommendation="Set access token expiry to 15m or shorter for better security."
                    )

            # Check algorithm configuration
            if 'HS256' not in content and 'algorithm' in content:
                self.add_finding(
                    title="Non-Standard JWT Algorithm",
                    description="JWT signing algorithm might not be explicitly set to HS256. "
                              "This could lead to algorithm confusion attacks.",
                    file_path=relative_path,
                    severity="LOW",
                    recommendation="Explicitly specify 'HS256' algorithm in JWT configuration."
                )
                
        except Exception as e:
            self.logger.error(f"Error analyzing auth service {auth_service_path}: {e}")
    
    def _check_middleware_configuration(self, target_path: str):
        """Check middleware configuration - Check global configuration in server.js"""
        server_path = os.path.join(target_path, 'server.js')
        
        if not os.path.exists(server_path):
            return
        
        try:
            content = self.read_file_safe(server_path)
            if not content:
                return
            
            relative_path = self.get_relative_path(server_path, target_path)

            # Check for global authentication middleware (may not be necessary, but worth a reminder)
            if 'authenticateToken' in content and 'app.use' in content:
                # If there is global JWT middleware, check if it is reasonable
                lines = content.split('\n')
                for i, line in enumerate(lines, 1):
                    if 'app.use' in line and 'authenticateToken' in line:
                        self.add_finding(
                            title="Global JWT Middleware Detected",
                            description="Found global JWT middleware in server.js. "
                                      "This will require authentication for ALL routes including public ones.",
                            file_path=relative_path,
                            line_number=i,
                            severity="HIGH",
                            recommendation="Consider using route-specific JWT middleware instead of global middleware "
                                         "to avoid blocking public endpoints."
                        )
            
        except Exception as e:
            self.logger.error(f"Error analyzing server configuration {server_path}: {e}")
    
    def generate_recommendation(self, issue_type: str) -> str:
        """Generate specific recommendation based on issue type"""
        if issue_type == "low_entropy":
            return """Improve JWT secret security:

1. Generate a strong secret:
   const crypto = require('crypto');
   const secret = crypto.randomBytes(64).toString('hex');

2. Store in environment variables:
   JWT_SECRET=your-generated-secret

3. Use different secrets for different environments
4. Rotate secrets periodically
5. Consider using asymmetric keys (RS256) for larger systems"""

        elif issue_type == "direct_jwt":
            return """Centralize JWT verification:

1. Create an auth service:
   // services/authService.js
   class AuthService {
     static verifyToken(token) {
       return jwt.verify(token, process.env.JWT_SECRET);
     }
   }

2. Update middleware:
   const AuthService = require('../services/authService');
   
   function authenticateToken(req, res, next) {
     try {
       const token = req.headers.authorization?.split(' ')[1];
       req.user = AuthService.verifyToken(token);
       next();
     } catch (err) {
       res.status(401).json({ error: 'Invalid token' });
     }
   }"""

        elif issue_type == "multiple_implementation":
            return """Consolidate JWT implementations:

1. Remove duplicate files
2. Create a single auth middleware directory:
   /middleware
     /auth
       index.js      - Main export
       verify.js     - Token verification
       generate.js   - Token generation
       refresh.js    - Token refresh logic

3. Update all imports to use the centralized version
4. Add tests to ensure consistent behavior"""

        else:  # incomplete_error
            return """Improve JWT error handling:

1. Handle specific JWT errors:
   try {
     const decoded = jwt.verify(token, secret);
     req.user = decoded;
   } catch (err) {
     if (err instanceof jwt.TokenExpiredError) {
       return res.status(401).json({ error: 'Token expired' });
     }
     if (err instanceof jwt.JsonWebTokenError) {
       return res.status(401).json({ error: 'Invalid token' });
     }
     return res.status(401).json({ error: 'Authentication failed' });
   }"""


# Test function
def test_plugin():
    """Test plugin basic functionality"""
    plugin = JWTConfigurationPlugin()
    
    print("Plugin Info:", plugin.get_plugin_info())
    print("Severity Level:", plugin.get_severity_level())
    print("âœ… Updated JWT Configuration Plugin initialized successfully")


if __name__ == '__main__':
    test_plugin()