#!/usr/bin/env python3
"""General security plugin: detects common hardcoded secrets, DB connection strings,
and permissive CORS configurations.
"""
import os
import re
from typing import List, Dict, Any, Optional

from plugins.base_plugin import BaseSecurityPlugin, SecurityFinding
import yaml


class GeneralSecurityPlugin(BaseSecurityPlugin):
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        super().__init__(config)
        self.name = 'general_security'
        # Merge sensible defaults to reduce noisy results
        defaults = {
            'allowlist_keys': ['TEST_SECRET', 'PLACEHOLDER', 'EXAMPLE_SECRET'],
            'exclude_paths': ['tests/', '__tests__/', 'fixtures/', 'node_modules/', '.venv/', 'venv/'],
            'secret_keys_allowlist': ['password', 'passwd', 'secret', 'api_key', 'apiKey', 'token', 'jwt_secret', 'jwt']
        }
        # Only set defaults for keys not provided by user config
        for k, v in defaults.items():
            if k not in self.config:
                self.config[k] = v

        # Legacy rules support (load rules_v1.yaml if enabled)
        self.legacy_rules: List[Dict[str, Any]] = []
        legacy_cfg = self.config.get('legacy_rules', {})
        include_debug = legacy_cfg.get('include_debug_rules', False)
        if legacy_cfg.get('enabled', True):
            rules_path = legacy_cfg.get('path', os.path.join(os.path.dirname(__file__), 'rules_v1.yaml'))
            try:
                if os.path.exists(rules_path):
                    with open(rules_path, 'r', encoding='utf-8') as rf:
                        loaded = yaml.safe_load(rf) or []
                        # compile regex for faster matching later
                        for r in loaded:
                            # skip any malformed entries (e.g., null lines) that aren't mappings
                            if not isinstance(r, dict):
                                self.logger.debug("Skipping non-dict legacy rule entry")
                                continue
                            try:
                                # skip debug-only rules unless explicitly enabled in config
                                if r.get('mode') == 'debug' and not include_debug:
                                    continue
                                r['compiled'] = re.compile(r.get('regex', ''), re.MULTILINE | re.DOTALL)
                                self.legacy_rules.append(r)
                            except re.error:
                                self.logger.warning(f"Invalid regex in legacy rule {r.get('id')}")
                    self.logger.info(f"Loaded {len(self.legacy_rules)} legacy rules from {rules_path}")
                else:
                    self.logger.info(f"Legacy rules file not found at {rules_path}")
            except Exception as e:
                self.logger.warning(f"Failed to load legacy rules: {e}")

    def get_plugin_info(self) -> Dict[str, str]:
        return {
            'name': 'general_security',
            'version': '0.1.0',
            'description': 'Detect generic security issues such as hardcoded secrets, DB URLs and permissive CORS.'
        }

    def get_severity_level(self) -> str:
        return 'MEDIUM'

    def scan(self, target_path: str) -> List[SecurityFinding]:
        # Walk files under target_path and perform lightweight pattern checks
        for root, dirs, files in os.walk(target_path):
            # Respect skip directories from base class config
            dirs[:] = [d for d in dirs if not self.should_skip_directory(os.path.join(root, d))]

            for fname in files:
                fpath = os.path.join(root, fname)
                # Respect plugin-configured exclude paths early to avoid scanning tests/fixtures etc.
                exclude_paths = self.config.get('exclude_paths', [])
                if any(p and p in fpath for p in exclude_paths):
                    # skip this file entirely
                    continue
                # allow additional common config file extensions even if base class
                # doesn't include them (e.g., .conf, .env, .ini, .yaml, .yml, .txt)
                extra_exts = {'.conf', '.env', '.ini', '.yaml', '.yml', '.json', '.txt'}
                file_ext = os.path.splitext(fpath)[1].lower()
                if not (self.is_file_scannable(fpath) or file_ext in extra_exts):
                    continue

                content = self.read_file_safe(fpath)
                if not content:
                    continue

                # Apply legacy rules if present
                if self.legacy_rules:
                    for rule in self.legacy_rules:
                        try:
                            matches = list(rule['compiled'].finditer(content))
                        except Exception:
                            matches = []
                        for m in matches:
                            title = rule.get('name') or rule.get('id')
                            severity = rule.get('severity', self.get_severity_level())
                            desc = rule.get('description', '')
                            rec = rule.get('recommendation')
                            line_no = self._estimate_line_number(content, m.start())
                            # Prevent duplicating findings for short allowlisted patterns
                            self.add_finding(
                                title=title,
                                description=f"{desc} -- match: {m.group(0)[:200]}",
                                file_path=fpath,
                                line_number=line_no,
                                severity=severity,
                                recommendation=rec,
                                rule_id=rule.get('id'),
                                rule_name=rule.get('name'),
                                rule_mode=rule.get('mode'),
                                confidence=rule.get('confidence', 'MEDIUM')
                            )

                # 1) hardcoded secrets (improved heuristic)
                # Require variable-like keys and a reasonably long secret value (to avoid short incidental matches)
                secret_keys = self.config.get('secret_keys_allowlist', ['password', 'passwd', 'secret', 'api_key', 'apiKey', 'token', 'jwt_secret', 'jwt'])
                secret_keys_re = r"(?:" + r"|".join([re.escape(k) for k in secret_keys]) + r")"
                # match patterns like: KEY = 'value' or "KEY": "value"; value must be at least 8 chars and not contain whitespace/newlines
                secret_pattern = re.compile(rf"(?i)({secret_keys_re})\s*[:=]\s*[\'\"]([A-Za-z0-9@#\$%\^&\-_=+\./\\~`{{}}\|]{{8,512}})[\'\"]")
                for m in secret_pattern.finditer(content):
                    key = m.group(1)
                    value = m.group(2)
                    # allowlist check: if key or file path is explicitly allowed, skip
                    allowlist_keys = [k.lower() for k in self.config.get('allowlist_keys', [])]
                    if key.lower() in allowlist_keys:
                        continue
                    exclude_paths = self.config.get('exclude_paths', [])
                    if any(p and p in fpath for p in exclude_paths):
                        continue

                    self.add_finding(
                        title=f'Hardcoded secret: {key}',
                        description=f'Found likely hardcoded secret key "{key}" in file. Value length: {len(value)}',
                        file_path=fpath,
                        line_number=self._estimate_line_number(content, m.start()),
                        severity='CRITICAL',
                        recommendation={
                            'summary': 'Remove hardcoded secrets and use environment variables or a secrets manager.',
                            'steps': [
                                'Move the secret into an environment variable or encrypted store.',
                                'Rotate the exposed secret immediately if used in production.',
                                'Ensure secrets are not committed to VCS.'
                            ]
                        },
                        confidence='HIGH'
                    )

                # 2) DB connection strings
                # match postgres://... or mysql://... regardless of surrounding quotes
                db_pattern = re.compile(r"(?i)(?:postgres(?:ql)?|mysql)://[^\s'\"`<>]+")
                for m in db_pattern.finditer(content):
                    self.add_finding(
                        title='Hardcoded DB connection string',
                        description='Found a database connection string in code or config which may contain credentials.',
                        file_path=fpath,
                        line_number=self._estimate_line_number(content, m.start()),
                        severity='HIGH',
                        recommendation='Move DB credentials to environment variables and avoid committing connection strings.',
                        confidence='HIGH'
                    )

                # 3) permissive CORS or wildcard origins (simple checks)
                # look for Access-Control-Allow-Origin: * or origin: '*' in JS/TS configs
                if re.search(r"Access-Control-Allow-Origin\s*:\s*\*", content) or re.search(r"origin\s*[:=]\s*[\'\"]\*\b", content):
                    self.add_finding(
                        title='Permissive CORS configuration',
                        description='Detected wildcard CORS origin which allows any origin to access resources.',
                        file_path=fpath,
                        line_number=None,
                        severity='MEDIUM',
                        recommendation={
                            'summary': 'Restrict CORS origins to a specific allowlist.',
                            'steps': [
                                'Replace wildcard origin with an explicit list of allowed origins.',
                                'If dynamic, validate and sanitize the Origin header before echoing it back.'
                            ]
                        },
                        confidence='LOW'
                    )

        return self.findings

    def _estimate_line_number(self, content: str, pos: int) -> Optional[int]:
        try:
            return content[:pos].count('\n') + 1
        except Exception:
            return None
