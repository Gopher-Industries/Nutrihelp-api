#!/usr/bin/env python3
"""
NutriHelp Security Scanner V2.0 - Main Entry Point
Modular security scanner main program
"""

import os
import sys
import argparse
import json
import re
import logging
from pathlib import Path

# Add the current directory to the Python path
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from core.scanner_engine import VulnerabilityScannerEngine
from core.config_manager import ConfigManager
from core.report_renderer import render_html_report


def setup_logging(verbose: bool = False):
    """Set up logging system"""
    level = logging.DEBUG if verbose else logging.INFO
    logging.basicConfig(
        level=level,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[logging.StreamHandler()]
    )


def main():
    """Main function"""
    parser = argparse.ArgumentParser(
        description='NutriHelp Security Scanner V2.0 - Modular security scanner',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
        Example usage:
        %(prog)s --target ../                    # Scan parent directory
        %(prog)s --target ../ --format json     # Output in JSON format
        %(prog)s --target ../ --output report.html --format html
        %(prog)s --config custom_config.yaml --target ../
                """
            )
    
    parser.add_argument('--target', '-t', required=True,
                       help='Target directory path')
    parser.add_argument('--config', '-c',
                       help='Configuration file path')
    parser.add_argument('--format', '-f', default='summary',
                       choices=['json', 'html', 'summary'],
                       help='Output format (default: summary)')
    parser.add_argument('--output', '-o',
                       help='Output file path (default: stdout)')
    parser.add_argument('--verbose', '-v', action='store_true',
                       help='Show verbose logs')
    parser.add_argument('--version', action='version', version='%(prog)s 2.0.0')
    
    args = parser.parse_args()

    # Set up logging
    setup_logging(args.verbose)
    logger = logging.getLogger("main")
    
    try:
        logger.info("Starting NutriHelp Security Scanner V2.0")

        # 1. Load configuration
        config_manager = ConfigManager(args.config)
        if not config_manager.validate_config():
            logger.error("Configuration validation failed")
            return 1

        # 2. Initialize scanner engine
        # Inject sensible default global excludes to reduce noise when scanning repository root
        # Do not overwrite user-provided settings; append missing defaults.
        extra_excludes = [
            'Vulnerability_Tool_V2',
            'Vulnerability_Tool',
            'node_modules',
            'tests',
            'test',
            '.pytest_cache',
            '__pycache__'
        ]

        full_cfg = config_manager.config or {}
        existing = full_cfg.get('global_exclude_paths', []) or []
        # ensure list
        if not isinstance(existing, list):
            existing = list(existing)

        for p in extra_excludes:
            if p not in existing:
                existing.append(p)

        full_cfg['global_exclude_paths'] = existing

        # Pass the full configuration object to the engine so global excludes are honored
        engine = VulnerabilityScannerEngine(full_cfg)

        # 3. Load plugins
        plugin_configs = config_manager.get_enabled_plugins()
        # Ensure general_security is enabled by default unless explicitly disabled
        if 'general_security' not in plugin_configs:
            plugin_configs['general_security'] = { 'enabled': True }
        engine.load_plugins(plugin_configs)
        
        if engine.stats['plugins_loaded'] == 0:
            logger.warning("No plugins loaded! Scanner will not find any issues.")

        # 4. Execute scan
        logger.info(f"Scanning target: {args.target}")
        scan_results = engine.scan_target(args.target)

        # 5. Generate output
        output_content = format_output(scan_results, args.format, config_manager)

        # 6. Write output
        if args.output:
            write_output_file(output_content, args.output, args.format)
            logger.info(f"Results saved to: {args.output}")
        else:
            print(output_content)

        # 7. Set exit code
        critical_count = scan_results['summary']['by_severity'].get('CRITICAL', 0)
        if critical_count > 0:
            logger.warning(f"Found {critical_count} critical vulnerabilities!")
            return 1
        
        logger.info("Scan completed successfully")
        return 0
        
    except FileNotFoundError as e:
        logger.error(f"File not found: {e}")
        return 1
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


def format_output(scan_results: dict, output_format: str, config_manager: ConfigManager) -> str:
    """Format output results"""
    if output_format == 'json':
        # Ensure findings include rule metadata (rule_id, rule_name, rule_mode, confidence)
        return json.dumps(scan_results, indent=2, ensure_ascii=False)
    
    elif output_format == 'html':
        # Use shared renderer for consistent output with API
        return render_html_report(scan_results, config_manager)
    
    elif output_format == 'summary':
        return generate_summary_report(scan_results)
    
    else:
        raise ValueError(f"Unsupported output format: {output_format}")


def generate_summary_report(scan_results: dict) -> str:
    """Generate summary report"""
    summary = scan_results['summary']
    findings = scan_results['findings']
    scan_info = scan_results['scan_info']
    
    lines = []
    lines.append("🔒 NutriHelp Vulnerability Scanner V2.0 Results")
    lines.append("=" * 50)
    lines.append("")

    # Scan information
    lines.append(f"📁 Target: {scan_info['target_path']}")
    lines.append(f"⏰ Scan Time: {scan_info['timestamp']}")
    lines.append(f"📊 Files Scanned: {scan_info['stats']['files_scanned']}")
    lines.append(f"🔌 Plugins Used: {scan_info['stats']['plugins_loaded']}")
    lines.append("")

    # Summary statistics
    lines.append("📊 Issues Found by Severity:")
    severity_colors = {
        'CRITICAL': '🔴',
        'HIGH': '🟠', 
        'MEDIUM': '🟡',
        'LOW': '🟢'
    }
    
    total_issues = summary['total']
    if total_issues == 0:
        lines.append("   ✅ No vulnerabilities found!")
    else:
        for severity in ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']:
            count = summary['by_severity'].get(severity, 0)
            if count > 0:
                color = severity_colors.get(severity, '⚪')
                lines.append(f"   {color} {severity}: {count}")
    
    lines.append("")
    lines.append(f"Total Issues: {total_issues}")

    # Plugin statistics
    if summary['by_plugin']:
        lines.append("")
        lines.append("🔌 Issues by Plugin:")
        for plugin_name, count in summary['by_plugin'].items():
            lines.append(f"   • {plugin_name}: {count}")

    # Critical issues details
    critical_findings = [f for f in findings if f.get('severity') == 'CRITICAL']
    if critical_findings:
        lines.append("")
        lines.append("🚨 CRITICAL ISSUES (Need immediate attention):")
        lines.append("-" * 40)
        
        for i, finding in enumerate(critical_findings[:5], 1):  # Only show the first 5
            lines.append(f"{i}. {finding['title']}")
            lines.append(f"   📁 File: {finding['file_path']}")
            if finding.get('line_number'):
                lines.append(f"   📍 Line: {finding['line_number']}")
            # include rule metadata if present
            rule_meta = []
            if finding.get('rule_id'):
                rule_meta.append(f"Rule ID: {finding.get('rule_id')}")
            if finding.get('rule_name'):
                rule_meta.append(f"Rule: {finding.get('rule_name')}")
            if finding.get('rule_mode'):
                rule_meta.append(f"Mode: {finding.get('rule_mode')}")
            if finding.get('confidence'):
                rule_meta.append(f"Confidence: {finding.get('confidence')}")
            if rule_meta:
                lines.append(f"   🔎 {' | '.join(rule_meta)}")
            lines.append(f"   📝 {finding['description']}")
            lines.append("")
        
        if len(critical_findings) > 5:
            lines.append(f"   ... and {len(critical_findings) - 5} more critical issues")

    # High priority issues overview
    high_findings = [f for f in findings if f.get('severity') == 'HIGH']
    if high_findings and len(high_findings) <= 3:  # Only show when high priority issues are few
        lines.append("")
        lines.append("🔶 HIGH PRIORITY ISSUES:")
        lines.append("-" * 30)
        
        for finding in high_findings:
            lines.append(f"• {finding['title']} ({finding['file_path']})")
    
    lines.append("")
    lines.append("💡 Use --format html for detailed visual report")
    lines.append("💡 Use --format json for machine-readable output")
    
    return '\n'.join(lines)


    # CLI previously had a large in-file renderer; replaced by shared renderer


def write_output_file(content: str, file_path: str, output_format: str):
    """Write output file"""
    # Ensure output directory exists
    output_dir = os.path.dirname(file_path)
    if output_dir and not os.path.exists(output_dir):
        os.makedirs(output_dir)

    # Determine encoding
    encoding = 'utf-8'
    
    with open(file_path, 'w', encoding=encoding) as f:
        f.write(content)


if __name__ == '__main__':
    sys.exit(main())