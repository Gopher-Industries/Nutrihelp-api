#!/usr/bin/env python3
"""
Safe batch rename script:
- Moves original files matching security_report_* and security_result_* into reports/legacy_backup/
- Generates new filenames using timestamp extracted from filename (YYYYMMDD_HHMMSS) or file mtime
- Writes a CSV mapping original -> new in reports/legacy_backup/rename_map.csv
- Dry-run mode lists planned actions; use --apply to perform
"""
import argparse
import csv
import os
import re
import shutil
from datetime import datetime

ROOT = os.path.dirname(os.path.dirname(__file__))
REPORTS_DIR = os.path.join(ROOT, 'reports')
BACKUP_DIR = os.path.join(REPORTS_DIR, 'legacy_backup')

PAT_REPORT = re.compile(r'security_report_(?P<ts>\d{8}_\d{6})(?:_(?P<tag>.+?))?\.html$')
PAT_RESULT = re.compile(r'security_result_(?P<ts>\d{8}_\d{6})(?:_(?P<tag>.+?))?\.json$')


def find_candidates():
    files = os.listdir(REPORTS_DIR)
    candidates = []
    for fn in files:
        if PAT_REPORT.match(fn) or PAT_RESULT.match(fn):
            candidates.append(fn)
    return sorted(candidates)


def extract_timestamp(fn):
    m = PAT_REPORT.match(fn) or PAT_RESULT.match(fn)
    if m:
        ts = m.group('ts')
        tag = m.group('tag')
        return ts, tag
    # fallback: use mtime
    p = os.path.join(REPORTS_DIR, fn)
    st = os.path.getmtime(p)
    ts = datetime.fromtimestamp(st).strftime('%Y%m%d_%H%M%S')
    return ts, None


def plan_rename(fn):
    ts, tag = extract_timestamp(fn)
    if fn.startswith('security_report_'):
        newbase = f'Vulnerability_Scan_Report_{ts}'
        ext = '.html'
    else:
        newbase = f'Vulnerability_Scan_Result_{ts}'
        ext = '.json'
    if tag:
        newbase = newbase + '_' + tag
    newfn = newbase + ext
    return newfn


def ensure_backup_dir():
    os.makedirs(BACKUP_DIR, exist_ok=True)


def perform(dry_run=True):
    candidates = find_candidates()
    if not candidates:
        print('No candidate files found.')
        return 0
    plan = []
    for fn in candidates:
        src = os.path.join(REPORTS_DIR, fn)
        newfn = plan_rename(fn)
        dst = os.path.join(REPORTS_DIR, newfn)
        # avoid overwriting existing target: if exists, append a counter
        if os.path.exists(dst):
            base, ext = os.path.splitext(newfn)
            i = 1
            while True:
                alt = f"{base}._{i}{ext}"
                altpath = os.path.join(REPORTS_DIR, alt)
                if not os.path.exists(altpath):
                    dst = altpath
                    newfn = alt
                    break
                i += 1
        plan.append((fn, newfn, src, dst))

    print(f'Planned renames: {len(plan)}')
    for old, newfn, src, dst in plan[:20]:
        print(f'{old} -> {newfn}')
    if len(plan) > 20:
        print('...')

    if dry_run:
        print('\nDry-run mode; no files moved. Use --apply to execute the moves.')
        return 0

    # perform
    ensure_backup_dir()
    map_csv = os.path.join(BACKUP_DIR, 'rename_map.csv')
    with open(map_csv, 'w', newline='') as fh:
        writer = csv.writer(fh)
        writer.writerow(['original', 'new', 'backup_path'])
        for old, newfn, src, dst in plan:
            # move original to backup
            bak = os.path.join(BACKUP_DIR, old)
            if not os.path.exists(bak):
                shutil.move(src, bak)
            else:
                # if backup exists, append counter
                base, ext = os.path.splitext(old)
                i = 1
                while True:
                    bak_alt = os.path.join(BACKUP_DIR, f"{base}._{i}{ext}")
                    if not os.path.exists(bak_alt):
                        shutil.move(src, bak_alt)
                        bak = bak_alt
                        break
                    i += 1
            # copy backup to new name in reports dir
            shutil.copy(bak, dst)
            writer.writerow([old, newfn, bak])
    print(f'Moved originals to {BACKUP_DIR} and wrote mapping to {map_csv}')
    return 0


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--apply', action='store_true', help='Actually perform moves')
    args = parser.parse_args()
    perform(dry_run=not args.apply)
